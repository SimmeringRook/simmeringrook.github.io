## The Core Design Process

The underlying theme of iterating on and releasing a minimal viable product was chosen to facilitate efficent paritioning of the desired feature set along with fast implementation and iteration. By necessity, this required a simple core design process. In the early stages of synthesis, the algorithm was defined by five steps:

1. Find/Choose an Equation
2. Translate Equation to Python
3. Plot results of Equation
4. Verify results and implement changes as necessary
5. Refactor

### 1. Choose an Equation

As mentioned in previous sections, each equation in GR very quickly increases in both mathematical and congnitive complexity. Therefore, it was paramount to start with the simplest descriptions in Schwarzschild: proper time and proper distance. Recall that we can simplify the line element (Equation $\ref{SchwarzschildWithC}$) by dictating what coordinates can change. Each corresponding invariant measurement is performed by finding the set of *rest* frames in which the change in spatial (or temporal) coordinates is minimized (typically zero)[^-21]. The corresponding invariant measurements for the stationary observers in Schwarzschild are then given as:

[^-21]: For proper distance, this is done be measuring the spacetime separation between two events that occur simultaneously; $t_{e1}=t_{e2}$, $dt=0$. Proper time is measured similarly: ${space}_{e1} = {space}_{e2}$, $d{space} = 0$.

### 2. Translate to Python

Given the relative simplicty of Equations $\ref{ShellDistance}$ and $\ref{ShellTime}$, the conversion to Python is straightfoward:

While the translation from a mathematical expression to a functional call is easy, due note that the readability has already decreased by a factor. This can be mitigated by trying to write the functions with Physicists in mind: 

However, the shorthand of using mathematical variable names does come at a cost. Recall, as noted in *Introduction: Computational Physics Background: "Variables, Dimensions, and their Representation"*, that the accepted design practices for *clean* code require variable names to be specific. "But why is using the variable names that allow a direct map between mathematical expression and progomatic representation not the *easiest* implementation?" At this stage, it most certaintly is, but we are also in the process of implementing the two simplest expressions in the simplest geometry for curved spacetime. Recall Equation $(\ref{GeneralSchwarzschildEOM})$ from *Introduction: Motivation*:

In the later parts of this thesis, my hope is that this equation will have lost some of its confounding nature, but that will be accomplished through plots and descriptions of objects interacting with the curvature, not through piece by piece deconstruction of the variables (at least, directly). A computational model of a system should be able to be parsed by someone who is fluent in the language of the program, iregardless if they have the model's domain knowledge, just as a mathematican should be able to parse a series of equations describing physical phenoma.

### 3. Plot

This portion definitely falls within the realm of an in-class assignment that can be given to a student in the PH 36X series with a simple implementation using Matplotlib:

### 4. Verify Results

Remembering that we are fundamently ploting a function that takes the form of $$f(x) = \frac{1}{\sqrt{1-\frac{1}{x}}}$$ It is very easy to compare the general shapes between the output generated by Cartographer and any other various plotting software. As more complex expressions are represented and interpreted by Cartographer, this stage will become more time consuming as the chance for mistakes increases in greater proportion than complexity. Also, more literature research will need to be conducting in conjuction to ensure that the results are comparable or reproducible to already existing figures.

### 5. Refactor

