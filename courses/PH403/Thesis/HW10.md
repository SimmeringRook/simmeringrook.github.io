To facilitate periodic testing and quick implementation, the desired functionality of Cartographer was divided into a series of milestones. Each milestone was choosen such that it gradually increased in complexity and laid the groundwork for subsequent milestones. This iterative design process is often referred to the minimal viable product: At the conclusion of each milestone, all corresponding functionality has been implemented and the code has been cleaned up and reorganized (refactored). 

This design process can be distilled into a series of five steps:

1. Find/Choose an Equation
2. Translate Equation to Python
3. Plot results of Equation
4. Verify results and implement changes as necessary
5. Refactor

The end goal of Cartographer is to generate visualizations correspoding to no-mass/low-mass particles moving through Schwarzschild spacetime and how they are scattered due to the pressence of a black hole. As mentioned previously in *Introduction: Motivation*, these geodesic equations are complex but we can leverage the fact that they are the result of algebraic compositions from simpler expressions. This very naturally allows us to work backwards from the end goal of visualizating something like Equation $(\ref{GeneralSchwarzschildEOM})$ to the very *building blocks* of describing the curvature of spacetime. 

The following subsections provide additional context for each step by detailing the process for implementing the effects of curvature on distance and time measurements. These subsections focus primarly on the computational implementation whereas *3.1 Distance, Time, and Embedding Diagrams* offers an analysis of the resulting visualizations and the physics behind them. 

We begin by isolating the descriptions of proper time and proper distance as measured by a shell observer using the line element (Equation $\ref{SchwarzschildWithC}$). Recall from *1.2.3 Space into Spacetime*, proper time and distance are invariant with respect to changing reference frames. By setting each differential in the line element to $0$ other than $dr$ or $dt$, we can obtain the expressions which allow us to discuss proper time and distance with respect to any stationary observer:

where we have introduced the shorthand of $f(r)= \sqrt{1 - \frac{2M}{r}}$ to simplify the expression and $d\Omega$ represents the angular components $\sin^2{\theta}d^2\varphi + d^2\theta$. Setting $d\Omega=0$, and examining just a change in $r$ or $t$ separately, we derive Equations $\ref{ShellDistance}$ and $\ref{ShellTime}$:

Having obtained our two equations to implement, the next step is to represent them in Python. Given the relative simplicty of Equations $\ref{ShellDistance}$ and $\ref{ShellTime}$ and their lack of dependancy on previous expressions, this conversion to Python is straightfoward:

This portion falls within the realm of an in-class assignment that can be given to a student in the PH 36X series, as it requires only basic familarity with Matplotlib and NumPy. Using the function as defined in the previous subsection, we choose convient values for `M` and `dr` initially. Specific values of `M` and `dr` can be used later on to verify the results from literature, but we want to be able to easily inspect the resulting plot for uncharacteristic behaviour.

Since there is a coordinate singularity at $r=2M$ and shell observers only exist outside the event horizon (see *1.2.4 Mass is Curvature*), we need to prevent the script from trying to divide by zero. This is simple enough by denoting our interval of $r$-coordinates to be exclusive $(2M,15M)$; programmatically, we do this by adding $dr$ to $2M$. The upper bound of $15M$ was chosen similar to the values of `M=5` and `dr=1`: it's just far enough away to display the shape of the plot without supressing the desired behaviour.

We are fundamently plotting a function that takes the form of 

With this in mind, it is very easy to compare the general shapes between the output generated by Cartographer and any other various plotting software due to the choice of parameters: `M=5`, `dr=1`, $(2M,15M)$. Using the following Mathematica code, we can compare that the function for proper distance has the same concavity and characteristic behaviour in both plots:

As more complex expressions are represented and interpreted by Cartographer, this stage becomes more time consuming due to the increased chance for mistakes in derivation and/or implementation. This stage also requires more literature review to ensure the results are comparable to already existing representations and interpretations. 

Refactoring is a catch-all term for:

- finding and fixing bugs from the result of adding new code or using existing code differently
- reorganizing code into logical divisions
- renaming variables to more clearly denote their purpose

The following is an example of refactoring the code written in the previous subsections. Recall that the functions were given descriptive names, but the variables used the same representation as their mathematical counterparts:

While the two representations are almost identitcal, especially for those used to representing math equations in LaTeX, the names of the functions and variables can be improved to be more descriptive. As is, a good custodian would insert comments into the code to add more context:

There is no specific set of requirements which state how code must be documented, but there is a set of *best practices* agreeded upon by various communities. For Python, this is given in the style guide of [PEP8](TODO:Link!), however, these recommendations are not as strict or easy to implement on a case by case basis as criteria for the References section of a paper. The general idea is to comment the code to allow easier interpretations of the purpose and/or functionality.

This, however, is treated as the bare minimum in being a good custodian of the code. Very often comments are not changed when a function is rewritten or bugfixed ( the analogy here is a figure or picture given with a problem statement for Math/Physics. It might show that the intersection of two lines/vectors is 90 degrees, but more often than not, the picture lies and doesn't match the values given by the problem.). Instead, it recommended to self document the code using descriptive variable/function/object names (in addition to comments).

While this has lost the readability from the almost LaTeX like implementation, it has removed the redundant comments everywhere denoting what `M` was, especially in relation to `M`'s dimensions. 

