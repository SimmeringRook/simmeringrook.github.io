To facilitate periodic testing and quick implementation, the desired functionality of Cartographer was divided into a series of milestones. Each milestone was choosen such that it gradually increased in complexity and laid the groundwork for subsequent milestones. This iterative design process is often referred to the minimal viable product: at the conclusion of each milestone, all corresponding functionality has been implemented and the code has been cleaned up and reorganized (refactored). 

This design process can be distilled into a series of five steps:

1. Choose an Equation
2. Translate Equation to Python
3. Generate Visualization for Equation
4. Verify Results and Change as Necessary
5. Refactor

The end goal of Cartographer is to generate visualizations correspoding to light and low-mass particles moving through Schwarzschild spacetime. As mentioned previously in *1.1 Motivation*, these geodesic equations are complex but we can leverage that they are the result of algebraic compositions from simpler expressions. This naturally allows us to work backwards from the end goal of visualizating something like Equation $(\ref{GeneralSchwarzschildEOM})$ to the building blocks of describing the curvature of spacetime. 

The following subsections provide additional context for each step by detailing the process of implementing the building blocks. These subsections focus primarly on the computational implementation whereas *3.1 Distance, Time, and Embedding Diagrams* offers an analysis of the resulting visualizations and the physics behind them. 

We begin by isolating the descriptions of proper time and proper distance as measured by a shell observer using the line element (Equation $\ref{SchwarzschildWithC}$). Recall from *1.2.3 Space into Spacetime* that proper time and distance are invariant with respect to changing reference frames. We can introduce the shorthand of $f(r)= \sqrt{1 - \frac{2M}{r}}$ and $d^2\Omega=\sin^2{\theta}d^2\varphi + d^2\theta$ to simplify the expression. other than $dr$ or $dt$, equal to $0$ we can obtain the expressions which allow us to discuss proper time and distance with respect to any stationary observer:

Then by setting $d^2\Omega=0$, we simplify the description of the line element to be changes in $r$ or $t$. Examining just a change in $r$ or $t$, we derive proper distance and time for the shell observer as Equations $\ref{ShellDistance}$ and $\ref{ShellTime}$:

Having obtained our two equations to implement, the next step is to represent them in Python. Given the relative simplicty of Equations $\ref{ShellDistance}$ and $\ref{ShellTime}$, they naturally lend themselves to being respresented as Python functions:

Like the funcitonal form of Equations $\ref{ShellDistance}$ and $\ref{ShellTime}$, these functions evaluate $dr_{shell}$ and $dt_{shell}$ for a specific $r$-coordinate (coresponding to the shell's location).

This portion falls within the realm of an in-class assignment that can be given to a student in the PH 36X series, as it requires only basic familarity with Matplotlib and NumPy. Using the distance function as defined in the previous subsection (`dr_shell(...)`), we choose convient values for `M` and `dr` initially to be able to easily inspect the resulting plot for uncharacteristic behaviour.. Specific values of `M` and `dr` will be used in *3.1 Distance, Time, and Embedding Diagrams* to verify the expected results from literature.

Since there is a coordinate singularity at $r=2M$ and shell observers only exist outside the event horizon (see *1.2.4 Mass is Curvature*), we need to adjust the interval of possible $r$-coordinates accordingly. We also need the size of the interval to be in a nice middle ground: just far enough away to display the shape of the plot and close enough to avoid supressing the desired behaviour. ; programmatically, 

We accomplish this by making the interval exclusive, $(2M,15M)$, and adding $dr$ to $2M$. Trial and error is used to find that $15M$ works as desired for the choosen values of `M=5` and `dr=1`. The figure generated by this implementation is shown in the following subsection, *2.2.4 Verify Results and Change as Necessary*, as Figure $\ref{DesignProcessVerify_Python}$.

Recall that for distance, we are plotting a function that takes the general form of 

With this in mind, it is very easy to compare the general shapes between the output generated by Cartographer and any other plotting software. Using the following Mathematica code, we compare the two functions by considering their concavity, shape, and behaviour as $x\rightarrow\infty$.

As more complex expressions are represented and interpreted by Cartographer, this stage becomes more time consuming due to the increased chance for mistakes in derivation and/or implementation. This stage is also when direct comparisions to any exisiting visualizations from literature are conducted. 

Refactoring is a catch-all term for:

- finding and fixing bugs from the result of adding new code or using existing code differently
- reorganizing code into logical divisions
- renaming variables to more clearly denote their purpose

The following is an example of refactoring the code written in the previous subsections. Recall that the functions and variables were given the same names as their mathematical counterparts:

While the two representations are almost identitcal, especially for those used to representing math equations in LaTeX, the names of the functions and variables are not *self-narrating*. Therefore, comments denoting the intention and use of each variable are expected. 

This, however, is treated as the bare minimum in being a good custodian of the code. Very often comments are not kept up-to-date with the changes to a function[^-21]. Instead, the programming communtity recommends that the code be self documenting: variable names should be descriptive and offer insight into the type of object they represented and that explicit programming statements are easier to understand than their elegant and brief counter-parts. These *best practices* are recommendations agreeded upon by the larger software development community. The Python organization takes this a step further by formally representing their community's best practices in the style guide released as [PEP 8](https://www.python.org/dev/peps/pep-0008/) [6]. By explicitly naming each variable (and function), we can free up the comments to provide a summary of the function's behaviour and reference the derivation of the expression.

[^-21]: An equivalent analogy are the pictures or diagrams included with many problem statements in math and physics. If they are not outright wrong, they end up being deceiving by misrepresenting angles, relative sizes, or trajectories.